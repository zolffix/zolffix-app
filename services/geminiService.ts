import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import { Quote } from '../types';

// The API key is accessed via process.env.API_KEY as per guidelines.
// It is assumed to be set in the deployment environment.

const getImageUrl = (keywords: string): string => {
  // Use Unsplash for high-quality, relevant images.
  // Keywords are comma-separated for better search results.
  const processedKeywords = keywords.replace(/[^a-zA-Z0-9\s,]/g, '').replace(/\s+/g, ',');
  return `https://source.unsplash.com/1080x1080/?${encodeURIComponent(processedKeywords)}`;
};

const getMockQuote = (category: string): Quote => {
  // Using a simpler, more reliable keyword combination for mock quotes
  const keywords = `${category},nature,dark`;
  return {
    id: `mock-${Date.now()}-${Math.random()}`,
    text: `This is a mock inspirational quote about ${category}. Stay positive and keep pushing forward!`,
    author: 'Zolffix AI',
    category,
    imageUrl: getImageUrl(keywords),
    imageKeyword: category,
  };
};

export const generateQuote = async (category: string): Promise<Quote> => {
  try {
    const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
    // Refined prompt for more emotionally resonant quotes and better image keywords.
    const prompt = `Generate an original, deeply thoughtful, and emotionally resonant one-sentence quote about "${category}". The tone must be poetic, profound, and avoid clich√©s. The author must be "Zolffix AI". Also, provide a single, powerful, one-word English keyword (e.g., 'solitude', 'resilience', 'journey', 'ocean', 'forest') that is highly suitable for finding a matching cinematic, dark, moody, and beautiful background image for the quote. Format the response as a single JSON object with keys: "text" (string), "author" (string), and "imageKeyword" (string).`;
    
    const response: GenerateContentResponse = await ai.models.generateContent({
        model: 'gemini-2.5-flash',
        contents: prompt,
        config: {
            responseMimeType: "application/json",
        },
    });

    let textResponse = response.text.trim();
    // Handle potential markdown code block wrapping from the API
    if (textResponse.startsWith("```json")) {
        textResponse = textResponse.slice(7, -3).trim();
    } else if (textResponse.startsWith("```")) {
        textResponse = textResponse.slice(3, -3).trim();
    }

    let jsonResponse;
    try {
        jsonResponse = JSON.parse(textResponse);
    } catch (e) {
        console.error("Failed to parse JSON from Gemini:", textResponse);
        throw new Error("Invalid JSON response from Gemini API");
    }

    // Updated logic to use the new 'imageKeyword' string property.
    if (jsonResponse.text && jsonResponse.author && typeof jsonResponse.imageKeyword === 'string' && jsonResponse.imageKeyword.trim() !== '') {
      const keywords = `${jsonResponse.imageKeyword},dark,cinematic,realistic,beautiful`;
      
      return {
        id: `gemini-${Date.now()}-${Math.random()}`,
        text: jsonResponse.text,
        author: jsonResponse.author,
        category,
        imageUrl: getImageUrl(keywords),
        imageKeyword: jsonResponse.imageKeyword,
      };
    } else {
        console.error("Invalid JSON structure from Gemini:", jsonResponse);
        throw new Error("Invalid JSON structure from Gemini API");
    }
  } catch (error) {
    console.error("Error generating quote with Gemini:", error);
    return getMockQuote(category); // Fallback to mock data on error
  }
};

export const generateImage = async (prompt: string): Promise<string> => {
    try {
        const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
        const response = await ai.models.generateImages({
            model: 'imagen-3.0-generate-002',
            prompt: prompt,
            config: {
                numberOfImages: 1,
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
            return base64ImageBytes;
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        console.error("Error generating image with Gemini:", error);
        throw error; // Re-throw to be handled by the caller
    }
};